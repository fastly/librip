#!/usr/bin/python
#
# Copyright 2014 Fastly, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# read_rip consumes a trace file generated by a librip consumer and
# outputs thread status.

import sys, re, os, getopt, subprocess, bisect, struct
import zlib, gzip, cStringIO
from collections import defaultdict

USAGE = """\
read_rip [-e <path-to-executable>] [-r <path-to-librip-output>] [-t] [-v]
"""

NM_P_RE = re.compile(r'^([^ ]+) [^ ] ([0-9a-f]+) ([0-9a-f]+)', re.I)


def usage():
  print USAGE
  sys.exit(0)


def main():
  (opt_list, args) = getopt.gnu_getopt(sys.argv[1:], 'e:hr:tv', ['help'])
  if args :
    raise getopt.GetoptError('unexpected non-option argument(s): %r' % (args,))

  by_tid = False
  exe_filename = None
  ring_filename = None
  verbose_mode = False
  for (opt, val) in opt_list :
    if opt == '--help' or opt == '-h':
      usage()
    elif opt == '-e' :
      if exe_filename is not None :
        raise getopt.GetoptError('duplicate option -e')
      exe_filename = val
    elif opt == '-r' :
      if ring_filename is not None :
        raise getopt.GetoptError('duplicate option -r')
      ring_filename = val
    elif opt == '-t' :
      by_tid = True
    elif opt == '-v' :
      verbose_mode = True

  if exe_filename is None :
    raise getopt.GetoptError('Executable must be specified')

  if ring_filename is None :
    ring_filename = 'rip_ring'

  doit(exe_filename, ring_filename, verbose_mode, by_tid)


class SymbolTable(object):
  def __init__(self, exe_filename):
    self.symbols = []
    for line in subprocess.Popen(['nm', '-P', exe_filename],
        stdout=subprocess.PIPE).communicate()[0].split('\n') :
      m = NM_P_RE.match(line)
      if m :
        (name, addr, size) = m.groups()
        addr = int(addr, 16)
        size = int(size, 16)
        self.symbols.append((name, addr, size))
    self.symbols.sort(key=lambda (name, addr, size) : addr)
    self.addrs = [x[1] for x in self.symbols]

  def lookup(self, addr):
    i = bisect.bisect_right(self.addrs, addr)
    if i == 0 : # lower than the first entry
      return None
    (sym_name, sym_addr, sym_size) = self.symbols[i-1]
    offset = addr - sym_addr
    if offset < sym_size :
      return (sym_name, offset)
    else:
      return None


def addrs2locations(addrs, exe_filename):
  addrs_str = '\n'.join(map(hex, addrs))
  locations_str = subprocess.Popen(['addr2line', '-se', exe_filename],
      stdin=subprocess.PIPE, stdout=subprocess.PIPE).communicate(addrs_str)[0]
  locations = locations_str.rstrip().split('\n')
  assert len(addrs) == len(locations), repr(locations_str)

  for (i, location) in enumerate(locations[:]) :
    if location == '??:0' :
      locations[i] = hex(addrs[i])

  return locations


def read_ring(ring_filename, by_tid, verbose_mode):
  addr_tid = []
  f = open(ring_filename, 'rb')
  d = f.read(64+256)

  if d.startswith('\x1f\x8b\x08') :  # gzip
    f.seek(0)
    f = gzip.GzipFile(fileobj=f, mode='rb')
    d = f.read(64+256)
  elif d.startswith('\x78\x9c') :  # old ripring's deflateInit defaults
    f = cStringIO.StringIO(zlib.decompress(d + f.read()))
    d = f.read(64+256)

  tid = 0
  while d != '' :
    assert len(d) == 64+256
    start = 0
    ctr = 0
    name = struct.unpack('64s', d[:64])[0].rstrip('\0')
    ctr_addr_list = struct.unpack('<32Q', d[64:])

    # The top 8 bits contain the slot counter, the remaining 24 bits contain
    # the address.  We should sign-extend the 24-bit address, but it does not
    # matter because we do not have instrumentation (or symbols) in anything
    # that is mapped into the higher half of the address space.
    #
    # Split the two out into a tuple: (ctr, addr).  Drop empty entries.
    # For an unused thread slot ctr_addr_list will end up empty.

    ctr_addr_list = [((entry & (0xff << 56)) >> 56, entry & 0x00ffffffffffffff)
                     for entry in ctr_addr_list
                     if entry != 0]

    if ctr_addr_list :
      # ctr_addr_list is a ring buffer.  The counter wraps around.  Find the
      # discontinuity in numbering modulo 256 or where the counter and addr
      # are all 1's (signifies an exit entry).  The entry after it is the
      # oldest entry.  Rotate the list to move that entry to the front.
      # The list will be thus in chronological order.  Example:
      # Before:   253 254 255 0 1 2 3 .. 24 249 250 251 252
      # After:    249 250 251 252 253 254 255 0 1 2 3 .. 24

      disco = None
      exited_thread = False
      for i in range(len(ctr_addr_list)-1) :
        curr_entry, next_entry = ctr_addr_list[i], ctr_addr_list[i+1]
        if next_entry[0] == 0xff and next_entry[1] == 0x00ffffffffffffff :
          disco = i+2
          exited_thread = True
          break
        elif next_entry[0] != (curr_entry[0] + 1) & 0xff :
          disco = i+1

      if disco is not None :
        ctr_addr_list = ctr_addr_list[disco:] + ctr_addr_list[:disco]

      # Don't include exited thread history unless by_tid and in verbose mode
      if by_tid :
        if verbose_mode or not exited_thread:
          for (ctr, addr) in ctr_addr_list:
            addr_tid.append((addr, tid, name, ctr))
      elif not exited_thread:
        # The latest (most recent) entry is at the end after the rotation above
        (ctr, addr) = ctr_addr_list[-1]
        addr_tid.append((addr, tid, name, ctr))

    d = f.read(64+256)
    tid += 1
  return addr_tid


def doit_by_tid(ring_filename, addrs, tid2name, tid2addrs, verbose_mode):
  for (addr, tid, name, ctr) in read_ring(ring_filename, True, verbose_mode) :
    if not tid in tid2name:
      tid2name[tid] = name
    addrs.add(addr)
    tid2addrs[tid].append((ctr, addr))


def doit_by_func(exe_filename, ring_filename, addrs, func2addr_and_tid, verbose_mode):
  st = SymbolTable(exe_filename)

  for (addr, tid, name, ctr) in read_ring(ring_filename, False, verbose_mode) :
    addrs.add(addr)
    r = st.lookup(addr)
    if r is not None :
      func = r[0]
    else:
      func = 'UNKNOWN'
    func2addr_and_tid[func].append((addr, tid))


def get_matrix(exe_filename, addrs):
  addrs_list = list(addrs)
  location2addrs = defaultdict(set)
  addr2location = {}
  for (i, location) in enumerate(addrs2locations(addrs_list, exe_filename)) :
    addr = addrs_list[i]
    addr2location[addr] = location
    location2addrs[location].add(addr)

  return (location2addrs, addr2location)


def print_by_tid(tid2addrs, tid2name, location2addrs,  addr2location, verbose_mode):
  for key in sorted(tid2addrs) :
    locations = []

    for (ctr, addr) in tid2addrs[key] :
      location = addr2location[addr]
      if verbose_mode and ctr == 0xff and addr == 0x00ffffffffffffff :
        locations.append('EXIT')
      elif verbose_mode or len(location2addrs[location]) > 1 :
        locations.append('{%d}%s<%#x>' % (ctr, location, addr))
      else:
        locations.append('{%d}%s' % (ctr, location))

    if len(locations) == 1 :
      continue
    else:
      print "%s[%d]: %s\n" % (tid2name[key], key, ', '.join(locations))


def print_by_func(func2addr_and_tid, location2addrs, addr2location, verbose_mode):
  for (func, addr_tid_list) in sorted(func2addr_and_tid.items(),
      key=lambda (func, addr_tid_list): -len(addr_tid_list)) :

    addr2tids = defaultdict(list)
    for (addr, tid) in addr_tid_list :
      addr2tids[addr].append(tid)

    addr2tids_str_items = []
    for addr in sorted(addr2tids.keys()) :
      location = addr2location[addr]
      if verbose_mode or len(location2addrs[location]) > 1 :
        location_str = '%s<%#x>' % (location, addr)
      else:
        location_str = location

      tids = addr2tids[addr]
      if verbose_mode :
        tids_str = '[%s]' % (', '.join(map(str,sorted(tids))),)
      else:
        tids_str = '(%d)' % (len(tids),)

      addr2tids_str_items.append(location_str+' '+tids_str)

    addr2tids_str = '; '.join(addr2tids_str_items)
    print '%s : %d thread%s, %d location%s: %s' % (
      func,
      len(addr_tid_list), ['','s'][len(addr_tid_list) != 1],
      len(addr2tids), ['','s'][len(addr2tids) != 1],
      addr2tids_str)


def doit(exe_filename, ring_filename, verbose_mode, by_tid):
  addrs = set()

  if by_tid :
    tid2addrs = defaultdict(list)
    tid2name = {}
    doit_by_tid(ring_filename, addrs, tid2name, tid2addrs, verbose_mode)
    (location2addrs, addr2location) = get_matrix(exe_filename, addrs)
    print_by_tid(tid2addrs, tid2name, location2addrs, addr2location, verbose_mode)
  else:
    func2addr_and_tid = defaultdict(list)
    doit_by_func(exe_filename, ring_filename, addrs, func2addr_and_tid, verbose_mode)
    (location2addrs, addr2location) = get_matrix(exe_filename, addrs)
    print_by_func(func2addr_and_tid, location2addrs, addr2location, verbose_mode)


if __name__ == '__main__' :
  main()

# vim:set et ts=2 sw=2 sts=2:
